create terraform code for the following by using variables(input&output),loop,provider,provisioners, and add the comment to all lines of terrafrom code 
-----------------------------
# 1. Define the AWS Provider Configuration
provider "aws" {
  region = var.aws_region  # AWS region provided by variable
}

# 2. Define Input Variables
variable "aws_region" {
  description = "The AWS region to deploy the resources in"
  type        = string
  default     = "us-east-1"  # Default AWS region
}

variable "user_names" {
  description = "List of IAM user names to be created"
  type        = list(string)
  default     = ["user1", "user2"]  # Example list of IAM users
}

variable "group_name" {
  description = "The IAM group to assign users to"
  type        = string
  default     = "developers"  # Default group for developers
}

variable "managed_policy_arn" {
  description = "The ARN of the managed IAM policy to attach"
  type        = string
  default     = "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess"  # Example policy: S3 Read-Only Access
}

# 3. Create an IAM Group (if not already existing)
resource "aws_iam_group" "group" {
  name = var.group_name
}

# 4. Loop to Create IAM Users from the input list
resource "aws_iam_user" "users" {
  count = length(var.user_names)  # Loop through each user name

  name = var.user_names[count.index]  # Assign the name based on the loop index
}

# 5. Attach Users to the IAM Group using a Loop
resource "aws_iam_group_membership" "group_membership" {
  count = length(var.user_names)  # Loop through users for membership

  group = aws_iam_group.group.name  # Attach each user to the group
  users = [aws_iam_user.users[count.index].name]  # Attach the corresponding user
}

# 6. Attach Managed Policy to IAM Group
resource "aws_iam_policy_attachment" "group_policy_attachment" {
  name       = "${var.group_name}-policy-attachment"
  policy_arn = var.managed_policy_arn  # Attach the managed policy to the group
  groups     = [aws_iam_group.group.name]
}

# 7. Create Access Keys for the IAM Users using a Loop
resource "aws_iam_access_key" "user_access_keys" {
  count = length(var.user_names)  # Loop through each user to create access keys

  user = aws_iam_user.users[count.index].name  # Assign access keys to the respective user
}

# 8. Output the Access Key ID and Secret Access Key for each user
output "access_keys" {
  value = [
    for i in range(length(var.user_names)) : {
      user_name        = aws_iam_user.users[i].name
      access_key_id    = aws_iam_access_key.user_access_keys[i].id
      secret_access_key = aws_iam_access_key.user_access_keys[i].secret
    }
  ]
}

--------------------------------
# AWS VPC Course Outline: From Basics to Advanced with Terraform

## Level 1: Fundamentals
### Module 1: Introduction to VPC and Terraform Basics
1. Understanding VPC Concepts
   - What is Amazon VPC?
   - VPC components overview
   - Public vs Private subnets
   - Network Address Translation (NAT)

2. Terraform Fundamentals for AWS
   - Terraform configuration basics
   - AWS provider configuration
   - State management introduction
   - Basic Terraform commands

### Module 2: Basic VPC Setup
1. Creating Your First VPC
   - Basic VPC configuration
   - CIDR block planning
   - Main route table setup
   - Internet Gateway creation and attachment
---------------------
# Define input variables
variable "region" {
  description = "AWS region where the resources will be created" # Description of the region variable
  type        = string # Data type of the region variable
  default     = "us-east-1" # Default value for the region variable
}

variable "vpc_cidr" {
  description = "CIDR block for the VPC, defining its IP range" # Description of the VPC CIDR block
  type        = string # Data type of the VPC CIDR block
  default     = "10.0.0.0/16" # Default value for the VPC CIDR block
}

variable "tags" {
  description = "Tags to apply to all resources" # Description of the tags variable
  type        = map(string) # Data type of the tags variable
  default     = { Project = "Basic VPC Setup" } # Default tags
}

# Define the AWS provider
provider "aws" {
  region = var.region # Use the region variable to set the AWS region
}

# Create a VPC
resource "aws_vpc" "main_vpc" {
  cidr_block = var.vpc_cidr # Use the VPC CIDR block variable

  tags = merge(var.tags, { Name = "Main-VPC" }) # Tag the VPC with a name for identification
}

# Create an Internet Gateway
resource "aws_internet_gateway" "main_igw" {
  vpc_id = aws_vpc.main_vpc.id # Attach the Internet Gateway to the created VPC

  tags = merge(var.tags, { Name = "Main-Internet-Gateway" }) # Tag the Internet Gateway with a name for identification
}

# Create the Main Route Table
resource "aws_route_table" "main_route_table" {
  vpc_id = aws_vpc.main_vpc.id # Associate the route table with the created VPC

  tags = merge(var.tags, { Name = "Main-Route-Table" }) # Tag the route table with a name for identification
}

# Add a default route to the Internet Gateway
resource "aws_route" "default_route" {
  route_table_id         = aws_route_table.main_route_table.id # Reference the route table ID for the route
  destination_cidr_block = "0.0.0.0/0" # Define the destination CIDR block for internet access
  gateway_id             = aws_internet_gateway.main_igw.id # Use the Internet Gateway ID for the route
}

# Output the VPC ID
output "vpc_id" {
  value       = aws_vpc.main_vpc.id # Output the ID of the created VPC
  description = "The ID of the created VPC." # Description of the VPC ID output
}

# Output the Internet Gateway ID
output "igw_id" {
  value       = aws_internet_gateway.main_igw.id # Output the ID of the created Internet Gateway
  description = "The ID of the created Internet Gateway." # Description of the Internet Gateway ID output
}

# Output the Main Route Table ID
output "main_route_table_id" {
  value       = aws_route_table.main_route_table.id # Output the ID of the created Main Route Table
  description = "The ID of the Main Route Table." # Description of the Main Route Table ID output
}

-------------------------

2. Subnet Management
   - Public subnet creation
   - Private subnet creation
   - Understanding Availability Zones
   - Subnet CIDR calculations
----------------------
# Define input variables
variable "region" {
  description = "AWS region where the resources will be created" # Description of the region variable
  type        = string # Data type of the region variable
  default     = "us-east-1" # Default value for the region variable
}

variable "vpc_cidr" {
  description = "CIDR block for the VPC, defining its IP range" # Description of the VPC CIDR block
  type        = string # Data type of the VPC CIDR block
  default     = "10.0.0.0/16" # Default value for the VPC CIDR block
}

variable "availability_zones" {
  description = "List of availability zones for subnets" # Description of the availability zones variable
  type        = list(string) # Data type of the availability zones variable
  default     = ["us-east-1a", "us-east-1b"] # Default values for the availability zones
}

variable "tags" {
  description = "Tags to apply to all resources" # Description of the tags variable
  type        = map(string) # Data type of the tags variable
  default     = { Project = "Basic VPC Setup" } # Default tags
}

# Define the AWS provider
provider "aws" {
  region = var.region # Use the region variable to set the AWS region
}

# Create a VPC
resource "aws_vpc" "main_vpc" {
  cidr_block = var.vpc_cidr # Use the VPC CIDR block variable

  tags = merge(var.tags, { Name = "Main-VPC" }) # Tag the VPC with a name for identification
}

# Create an Internet Gateway
resource "aws_internet_gateway" "main_igw" {
  vpc_id = aws_vpc.main_vpc.id # Attach the Internet Gateway to the created VPC

  tags = merge(var.tags, { Name = "Main-Internet-Gateway" }) # Tag the Internet Gateway with a name for identification
}

# Create the Main Route Table
resource "aws_route_table" "main_route_table" {
  vpc_id = aws_vpc.main_vpc.id # Associate the route table with the created VPC

  tags = merge(var.tags, { Name = "Main-Route-Table" }) # Tag the route table with a name for identification
}

# Add a default route to the Internet Gateway
resource "aws_route" "default_route" {
  route_table_id         = aws_route_table.main_route_table.id # Reference the route table ID for the route
  destination_cidr_block = "0.0.0.0/0" # Define the destination CIDR block for internet access
  gateway_id             = aws_internet_gateway.main_igw.id # Use the Internet Gateway ID for the route
}

# Create Public Subnets
resource "aws_subnet" "public_subnets" {
  count                   = length(var.availability_zones) # Create one public subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = true # Enable public IP assignment for instances

  tags = merge(var.tags, { Name = "Public-Subnet-${count.index + 1}" }) # Tag each public subnet with a name
}

# Create Private Subnets
resource "aws_subnet" "private_subnets" {
  count                   = length(var.availability_zones) # Create one private subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index + length(var.availability_zones)) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = false # Disable public IP assignment for instances

  tags = merge(var.tags, { Name = "Private-Subnet-${count.index + 1}" }) # Tag each private subnet with a name
}

# Output the VPC ID
output "vpc_id" {
  value       = aws_vpc.main_vpc.id # Output the ID of the created VPC
  description = "The ID of the created VPC." # Description of the VPC ID output
}

# Output the Internet Gateway ID
output "igw_id" {
  value       = aws_internet_gateway.main_igw.id # Output the ID of the created Internet Gateway
  description = "The ID of the created Internet Gateway." # Description of the Internet Gateway ID output
}

# Output the Main Route Table ID
output "main_route_table_id" {
  value       = aws_route_table.main_route_table.id # Output the ID of the created Main Route Table
  description = "The ID of the Main Route Table." # Description of the Main Route Table ID output
}

# Output Public Subnet IDs
output "public_subnet_ids" {
  value       = aws_subnet.public_subnets.*.id # Output the IDs of all created public subnets
  description = "The IDs of the created public subnets." # Description of the public subnet IDs output
}

# Output Private Subnet IDs
output "private_subnet_ids" {
  value       = aws_subnet.private_subnets.*.id # Output the IDs of all created private subnets
  description = "The IDs of the created private subnets." # Description of the private subnet IDs output
}

-----------------------
## Level 2: Intermediate Concepts
### Module 3: Network Security
1. Security Groups
   - Security group creation and management
   - Inbound and outbound rules
   - Security group best practices
   - Using dynamic blocks in Terraform
------------------
# Define input variables
variable "region" {
  description = "AWS region where the resources will be created" # Description of the region variable
  type        = string # Data type of the region variable
  default     = "us-east-1" # Default value for the region variable
}

variable "vpc_cidr" {
  description = "CIDR block for the VPC, defining its IP range" # Description of the VPC CIDR block
  type        = string # Data type of the VPC CIDR block
  default     = "10.0.0.0/16" # Default value for the VPC CIDR block
}

variable "availability_zones" {
  description = "List of availability zones for subnets" # Description of the availability zones variable
  type        = list(string) # Data type of the availability zones variable
  default     = ["us-east-1a", "us-east-1b"] # Default values for the availability zones
}

variable "tags" {
  description = "Tags to apply to all resources" # Description of the tags variable
  type        = map(string) # Data type of the tags variable
  default     = { Project = "Basic VPC Setup" } # Default tags
}

# Define the AWS provider
provider "aws" {
  region = var.region # Use the region variable to set the AWS region
}

# Create a VPC
resource "aws_vpc" "main_vpc" {
  cidr_block = var.vpc_cidr # Use the VPC CIDR block variable

  tags = merge(var.tags, { Name = "Main-VPC" }) # Tag the VPC with a name for identification
}

# Create an Internet Gateway
resource "aws_internet_gateway" "main_igw" {
  vpc_id = aws_vpc.main_vpc.id # Attach the Internet Gateway to the created VPC

  tags = merge(var.tags, { Name = "Main-Internet-Gateway" }) # Tag the Internet Gateway with a name for identification
}

# Create the Main Route Table
resource "aws_route_table" "main_route_table" {
  vpc_id = aws_vpc.main_vpc.id # Associate the route table with the created VPC

  tags = merge(var.tags, { Name = "Main-Route-Table" }) # Tag the route table with a name for identification
}

# Add a default route to the Internet Gateway
resource "aws_route" "default_route" {
  route_table_id         = aws_route_table.main_route_table.id # Reference the route table ID for the route
  destination_cidr_block = "0.0.0.0/0" # Define the destination CIDR block for internet access
  gateway_id             = aws_internet_gateway.main_igw.id # Use the Internet Gateway ID for the route
}

# Create Public Subnets
resource "aws_subnet" "public_subnets" {
  count                   = length(var.availability_zones) # Create one public subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = true # Enable public IP assignment for instances

  tags = merge(var.tags, { Name = "Public-Subnet-${count.index + 1}" }) # Tag each public subnet with a name
}

# Create Private Subnets
resource "aws_subnet" "private_subnets" {
  count                   = length(var.availability_zones) # Create one private subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index + length(var.availability_zones)) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = false # Disable public IP assignment for instances

  tags = merge(var.tags, { Name = "Private-Subnet-${count.index + 1}" }) # Tag each private subnet with a name
}

# Create Security Groups
resource "aws_security_group" "public_sg" {
  vpc_id = aws_vpc.main_vpc.id # Associate the security group with the created VPC

  tags = merge(var.tags, { Name = "Public-Security-Group" }) # Tag the security group with a name

  dynamic "ingress" {
    for_each = [
      { from_port = 80, to_port = 80, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] }, # Allow HTTP traffic
      { from_port = 443, to_port = 443, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] } # Allow HTTPS traffic
    ]
    content {
      from_port   = ingress.value.from_port # Specify the start port of the range
      to_port     = ingress.value.to_port # Specify the end port of the range
      protocol    = ingress.value.protocol # Specify the protocol
      cidr_blocks = ingress.value.cidr_blocks # Specify the allowed CIDR blocks
    }
  }

  egress {
    from_port   = 0 # Allow all outbound traffic
    to_port     = 0 # Allow all outbound traffic
    protocol    = "-1" # Allow all protocols
    cidr_blocks = ["0.0.0.0/0"] # Allow all destinations
  }
}

resource "aws_security_group" "private_sg" {
  vpc_id = aws_vpc.main_vpc.id # Associate the security group with the created VPC

  tags = merge(var.tags, { Name = "Private-Security-Group" }) # Tag the security group with a name

  ingress {
    from_port   = 22 # Allow SSH access
    to_port     = 22 # Allow SSH access
    protocol    = "tcp" # Use TCP protocol
    cidr_blocks = ["10.0.0.0/16"] # Restrict access to the VPC CIDR block
  }

  egress {
    from_port   = 0 # Allow all outbound traffic
    to_port     = 0 # Allow all outbound traffic
    protocol    = "-1" # Allow all protocols
    cidr_blocks = ["0.0.0.0/0"] # Allow all destinations
  }
}

# Output the VPC ID
output "vpc_id" {
  value       = aws_vpc.main_vpc.id # Output the ID of the created VPC
  description = "The ID of the created VPC." # Description of the VPC ID output
}

# Output the Internet Gateway ID
output "igw_id" {
  value       = aws_internet_gateway.main_igw.id # Output the ID of the created Internet Gateway
  description = "The ID of the created Internet Gateway." # Description of the Internet Gateway ID output
}

# Output the Main Route Table ID
output "main_route_table_id" {
  value       = aws_route_table.main_route_table.id # Output the ID of the created Main Route Table
  description = "The ID of the Main Route Table." # Description of the Main Route Table ID output
}

# Output Public Subnet IDs
output "public_subnet_ids" {
  value       = aws_subnet.public_subnets.*.id # Output the IDs of all created public subnets
  description = "The IDs of the created public subnets." # Description of the public subnet IDs output
}

# Output Private Subnet IDs
output "private_subnet_ids" {
  value       = aws_subnet.private_subnets.*.id # Output the IDs of all created private subnets
  description = "The IDs of the created private subnets." # Description of the private subnet IDs output
}

# Output Security Group IDs
output "public_sg_id" {
  value       = aws_security_group.public_sg.id # Output the ID of the public security group
  description = "The ID of the public security group." # Description of the public security group ID output
}

output "private_sg_id" {
  value       = aws_security_group.private_sg.id # Output the ID of the private security group
  description = "The ID of the private security group." # Description of the private security group ID output
}

------------
2. Network ACLs
   - NACL vs Security Groups
   - Stateless filtering
   - Rule number management
   - NACL best practices
--------------------
# Define input variables
variable "region" {
  description = "AWS region where the resources will be created" # Description of the region variable
  type        = string # Data type of the region variable
  default     = "us-east-1" # Default value for the region variable
}

variable "vpc_cidr" {
  description = "CIDR block for the VPC, defining its IP range" # Description of the VPC CIDR block
  type        = string # Data type of the VPC CIDR block
  default     = "10.0.0.0/16" # Default value for the VPC CIDR block
}

variable "availability_zones" {
  description = "List of availability zones for subnets" # Description of the availability zones variable
  type        = list(string) # Data type of the availability zones variable
  default     = ["us-east-1a", "us-east-1b"] # Default values for the availability zones
}

variable "tags" {
  description = "Tags to apply to all resources" # Description of the tags variable
  type        = map(string) # Data type of the tags variable
  default     = { Project = "Basic VPC Setup" } # Default tags
}

# Define the AWS provider
provider "aws" {
  region = var.region # Use the region variable to set the AWS region
}

# Create a VPC
resource "aws_vpc" "main_vpc" {
  cidr_block = var.vpc_cidr # Use the VPC CIDR block variable

  tags = merge(var.tags, { Name = "Main-VPC" }) # Tag the VPC with a name for identification
}

# Create an Internet Gateway
resource "aws_internet_gateway" "main_igw" {
  vpc_id = aws_vpc.main_vpc.id # Attach the Internet Gateway to the created VPC

  tags = merge(var.tags, { Name = "Main-Internet-Gateway" }) # Tag the Internet Gateway with a name for identification
}

# Create the Main Route Table
resource "aws_route_table" "main_route_table" {
  vpc_id = aws_vpc.main_vpc.id # Associate the route table with the created VPC

  tags = merge(var.tags, { Name = "Main-Route-Table" }) # Tag the route table with a name for identification
}

# Add a default route to the Internet Gateway
resource "aws_route" "default_route" {
  route_table_id         = aws_route_table.main_route_table.id # Reference the route table ID for the route
  destination_cidr_block = "0.0.0.0/0" # Define the destination CIDR block for internet access
  gateway_id             = aws_internet_gateway.main_igw.id # Use the Internet Gateway ID for the route
}

# Create Public Subnets
resource "aws_subnet" "public_subnets" {
  count                   = length(var.availability_zones) # Create one public subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = true # Enable public IP assignment for instances

  tags = merge(var.tags, { Name = "Public-Subnet-${count.index + 1}" }) # Tag each public subnet with a name
}

# Create Private Subnets
resource "aws_subnet" "private_subnets" {
  count                   = length(var.availability_zones) # Create one private subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index + length(var.availability_zones)) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = false # Disable public IP assignment for instances

  tags = merge(var.tags, { Name = "Private-Subnet-${count.index + 1}" }) # Tag each private subnet with a name
}

# Create Security Groups
resource "aws_security_group" "public_sg" {
  vpc_id = aws_vpc.main_vpc.id # Associate the security group with the created VPC

  tags = merge(var.tags, { Name = "Public-Security-Group" }) # Tag the security group with a name

  dynamic "ingress" {
    for_each = [
      { from_port = 80, to_port = 80, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] }, # Allow HTTP traffic
      { from_port = 443, to_port = 443, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] } # Allow HTTPS traffic
    ]
    content {
      from_port   = ingress.value.from_port # Specify the start port of the range
      to_port     = ingress.value.to_port # Specify the end port of the range
      protocol    = ingress.value.protocol # Specify the protocol
      cidr_blocks = ingress.value.cidr_blocks # Specify the allowed CIDR blocks
    }
  }

  egress {
    from_port   = 0 # Allow all outbound traffic
    to_port     = 0 # Allow all outbound traffic
    protocol    = "-1" # Allow all protocols
    cidr_blocks = ["0.0.0.0/0"] # Allow all destinations
  }
}

resource "aws_security_group" "private_sg" {
  vpc_id = aws_vpc.main_vpc.id # Associate the security group with the created VPC

  tags = merge(var.tags, { Name = "Private-Security-Group" }) # Tag the security group with a name

  ingress {
    from_port   = 22 # Allow SSH access
    to_port     = 22 # Allow SSH access
    protocol    = "tcp" # Use TCP protocol
    cidr_blocks = ["10.0.0.0/16"] # Restrict access to the VPC CIDR block
  }

  egress {
    from_port   = 0 # Allow all outbound traffic
    to_port     = 0 # Allow all outbound traffic
    protocol    = "-1" # Allow all protocols
    cidr_blocks = ["0.0.0.0/0"] # Allow all destinations
  }
}

# Create Network ACLs
resource "aws_network_acl" "public_nacl" {
  vpc_id = aws_vpc.main_vpc.id # Associate the NACL with the created VPC

  tags = merge(var.tags, { Name = "Public-NACL" }) # Tag the NACL with a name

  egress {
    protocol   = "-1" # Allow all protocols
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all outbound traffic
    from_port  = 0 # Allow all ports
    to_port    = 0 # Allow all ports
  }

  ingress {
    protocol   = "tcp" # Allow TCP protocol
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all inbound traffic
    from_port  = 80 # Allow HTTP traffic
    to_port    = 80 # Allow HTTP traffic
  }

  ingress {
    protocol   = "tcp" # Allow TCP protocol
    rule_no    = 110 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all inbound traffic
    from_port  = 443 # Allow HTTPS traffic
    to_port    = 443 # Allow HTTPS traffic
  }
}

resource "aws_network_acl" "private_nacl" {
  vpc_id = aws_vpc.main_vpc.id # Associate the NACL with the created VPC

  tags = merge(var.tags, { Name = "Private-NACL" }) # Tag the NACL with a name

  egress {
    protocol   = "-1" # Allow all protocols
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all outbound traffic
    from_port  = 0 # Allow all ports
    to_port    = 0 # Allow all ports
  }

  ingress {
    protocol   = "tcp" # Allow TCP protocol
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "10.0.0.0/16" # Restrict to VPC CIDR
    from_port  = 22 # Allow SSH traffic
    to_port    = 22 # Allow SSH traffic
  }
}

# Output the VPC ID
output "vpc_id" {
  value       = aws_vpc.main_vpc.id # Output the ID of the created VPC
  description = "The ID of the created VPC." # Description of the VPC ID output
}

# Output the Internet Gateway ID
output "igw_id" {
  value       = aws_internet_gateway.main_igw.id # Output the ID of the created Internet Gateway
  description = "The ID of the created Internet Gateway." # Description of the Internet Gateway ID output
}

# Output the Main Route Table ID
output "main_route_table_id" {
  value       = aws_route_table.main_route_table.id # Output the ID of the created Main Route Table
  description = "The ID of the Main Route Table." # Description of the Main Route Table ID output
}

# Output Public Subnet IDs
output "public_subnet_ids" {
  value       = aws_subnet.public_subnets.*.id # Output the IDs of all created public subnets
  description = "The IDs of the created public subnets." # Description of the public subnet IDs output
}

# Output Private Subnet IDs
output "private_subnet_ids" {
  value       = aws_subnet.private_subnets.*.id # Output the IDs of all created private subnets
  description = "The IDs of the created private subnets." # Description of the private subnet IDs output
}

# Output Security Group IDs
output "public_sg_id" {
  value       = aws_security_group.public_sg.id # Output the ID of the public security group
  description = "The ID of the public security group." # Description of the public security group ID output
}

output "private_sg_id" {
  value       = aws_security_group.private_sg.id # Output the ID of the private security group
  description = "The ID of the private security group." # Description of the private security group ID output
}

# Output Network ACL IDs
output "public_nacl_id" {
  value       = aws_network_acl.public_nacl.id # Output the ID of the public NACL
  description = "The ID of the public NACL." # Description of the public NACL ID output
}

output "private_nacl_id" {
  value       = aws_network_acl.private_nacl.id # Output the ID of the private NACL
  description = "The ID of the private NACL." # Description of the private NACL ID output
}
--------------------------------------------
### Module 4: Routing and Connectivity
1. Route Tables
   - Custom route table creation
   - Route propagation
   - Subnet associations
   - Route priority
--------------------------------------------
# Define input variables
variable "region" {
  description = "AWS region where the resources will be created" # Description of the region variable
  type        = string # Data type of the region variable
  default     = "us-east-1" # Default value for the region variable
}

variable "vpc_cidr" {
  description = "CIDR block for the VPC, defining its IP range" # Description of the VPC CIDR block
  type        = string # Data type of the VPC CIDR block
  default     = "10.0.0.0/16" # Default value for the VPC CIDR block
}

variable "availability_zones" {
  description = "List of availability zones for subnets" # Description of the availability zones variable
  type        = list(string) # Data type of the availability zones variable
  default     = ["us-east-1a", "us-east-1b"] # Default values for the availability zones
}

variable "tags" {
  description = "Tags to apply to all resources" # Description of the tags variable
  type        = map(string) # Data type of the tags variable
  default     = { Project = "Basic VPC Setup" } # Default tags
}

# Define the AWS provider
provider "aws" {
  region = var.region # Use the region variable to set the AWS region
}

# Create a VPC
resource "aws_vpc" "main_vpc" {
  cidr_block = var.vpc_cidr # Use the VPC CIDR block variable

  tags = merge(var.tags, { Name = "Main-VPC" }) # Tag the VPC with a name for identification
}

# Create an Internet Gateway
resource "aws_internet_gateway" "main_igw" {
  vpc_id = aws_vpc.main_vpc.id # Attach the Internet Gateway to the created VPC

  tags = merge(var.tags, { Name = "Main-Internet-Gateway" }) # Tag the Internet Gateway with a name for identification
}

# Create the Main Route Table
resource "aws_route_table" "main_route_table" {
  vpc_id = aws_vpc.main_vpc.id # Associate the route table with the created VPC

  tags = merge(var.tags, { Name = "Main-Route-Table" }) # Tag the route table with a name for identification
}

# Add a default route to the Internet Gateway
resource "aws_route" "default_route" {
  route_table_id         = aws_route_table.main_route_table.id # Reference the route table ID for the route
  destination_cidr_block = "0.0.0.0/0" # Define the destination CIDR block for internet access
  gateway_id             = aws_internet_gateway.main_igw.id # Use the Internet Gateway ID for the route
}

# Create Public Subnets
resource "aws_subnet" "public_subnets" {
  count                   = length(var.availability_zones) # Create one public subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = true # Enable public IP assignment for instances

  tags = merge(var.tags, { Name = "Public-Subnet-${count.index + 1}" }) # Tag each public subnet with a name
}

# Create Private Subnets
resource "aws_subnet" "private_subnets" {
  count                   = length(var.availability_zones) # Create one private subnet per availability zone
  vpc_id                  = aws_vpc.main_vpc.id # Associate with the created VPC
  cidr_block              = cidrsubnet(var.vpc_cidr, 8, count.index + length(var.availability_zones)) # Calculate CIDR block for each subnet
  availability_zone       = var.availability_zones[count.index] # Assign availability zone
  map_public_ip_on_launch = false # Disable public IP assignment for instances

  tags = merge(var.tags, { Name = "Private-Subnet-${count.index + 1}" }) # Tag each private subnet with a name
}

# Create Security Groups
resource "aws_security_group" "public_sg" {
  vpc_id = aws_vpc.main_vpc.id # Associate the security group with the created VPC

  tags = merge(var.tags, { Name = "Public-Security-Group" }) # Tag the security group with a name

  dynamic "ingress" {
    for_each = [
      { from_port = 80, to_port = 80, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] }, # Allow HTTP traffic
      { from_port = 443, to_port = 443, protocol = "tcp", cidr_blocks = ["0.0.0.0/0"] } # Allow HTTPS traffic
    ]
    content {
      from_port   = ingress.value.from_port # Specify the start port of the range
      to_port     = ingress.value.to_port # Specify the end port of the range
      protocol    = ingress.value.protocol # Specify the protocol
      cidr_blocks = ingress.value.cidr_blocks # Specify the allowed CIDR blocks
    }
  }

  egress {
    from_port   = 0 # Allow all outbound traffic
    to_port     = 0 # Allow all outbound traffic
    protocol    = "-1" # Allow all protocols
    cidr_blocks = ["0.0.0.0/0"] # Allow all destinations
  }
}

resource "aws_security_group" "private_sg" {
  vpc_id = aws_vpc.main_vpc.id # Associate the security group with the created VPC

  tags = merge(var.tags, { Name = "Private-Security-Group" }) # Tag the security group with a name

  ingress {
    from_port   = 22 # Allow SSH access
    to_port     = 22 # Allow SSH access
    protocol    = "tcp" # Use TCP protocol
    cidr_blocks = ["10.0.0.0/16"] # Restrict access to the VPC CIDR block
  }

  egress {
    from_port   = 0 # Allow all outbound traffic
    to_port     = 0 # Allow all outbound traffic
    protocol    = "-1" # Allow all protocols
    cidr_blocks = ["0.0.0.0/0"] # Allow all destinations
  }
}

# Create Network ACLs
resource "aws_network_acl" "public_nacl" {
  vpc_id = aws_vpc.main_vpc.id # Associate the NACL with the created VPC

  tags = merge(var.tags, { Name = "Public-NACL" }) # Tag the NACL with a name

  egress {
    protocol   = "-1" # Allow all protocols
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all outbound traffic
    from_port  = 0 # Allow all ports
    to_port    = 0 # Allow all ports
  }

  ingress {
    protocol   = "tcp" # Allow TCP protocol
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all inbound traffic
    from_port  = 80 # Allow HTTP traffic
    to_port    = 80 # Allow HTTP traffic
  }

  ingress {
    protocol   = "tcp" # Allow TCP protocol
    rule_no    = 110 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all inbound traffic
    from_port  = 443 # Allow HTTPS traffic
    to_port    = 443 # Allow HTTPS traffic
  }
}

resource "aws_network_acl" "private_nacl" {
  vpc_id = aws_vpc.main_vpc.id # Associate the NACL with the created VPC

  tags = merge(var.tags, { Name = "Private-NACL" }) # Tag the NACL with a name

  egress {
    protocol   = "-1" # Allow all protocols
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "0.0.0.0/0" # Allow all outbound traffic
    from_port  = 0 # Allow all ports
    to_port    = 0 # Allow all ports
  }

  ingress {
    protocol   = "tcp" # Allow TCP protocol
    rule_no    = 100 # Rule number for ordering
    action     = "allow" # Allow traffic
    cidr_block = "10.0.0.0/16" # Restrict to VPC CIDR
    from_port  = 22 # Allow SSH traffic
    to_port    = 22 # Allow SSH traffic
  }
}

# Associate Subnets with Route Table
resource "aws_route_table_association" "public_subnet_assoc" {
  count         = length(aws_subnet.public_subnets) # Loop over public subnets
  subnet_id     = aws_subnet.public_subnets[count.index].id # Subnet to associate
  route_table_id = aws_route_table.main_route_table.id # Associate with main route table
}

# Output the VPC ID
output "vpc_id" {
  value       = aws_vpc.main_vpc.id # Output the ID of the created VPC
  description = "The ID of the created VPC." # Description of the VPC ID output
}

# Output the Internet Gateway ID
output "igw_id" {
  value       = aws_internet_gateway.main_igw.id # Output the ID of the created Internet Gateway
  description = "The ID of the created Internet Gateway." # Description of the Internet Gateway ID output
}

# Output the Main Route Table ID
output "main_route_table_id" {
  value       = aws_route_table.main_route_table.id # Output the ID of the created Main Route Table
  description = "The ID of the Main Route Table." # Description of the Main Route Table ID output
}

# Output Public Subnet IDs
output "public_subnet_ids" {
  value       = aws_subnet.public_subnets.*.id # Output the IDs of all created public subnets
  description = "The IDs of the created public subnets." # Description of the public subnet IDs output
}

# Output Private Subnet IDs
output "private_subnet_ids" {
  value       = aws_subnet.private_subnets.*.id # Output the IDs of all created private subnets
  description = "The IDs of the created private subnets." # Description of the private subnet IDs output
}

# Output Security Group IDs
output "public_sg_id" {
  value       = aws_security_group.public_sg.id # Output the ID of the public security group
  description = "The ID of the public security group." # Description of the public security group ID output
}

output "private_sg_id" {
  value       = aws_security_group.private_sg.id # Output the ID of the private security group
  description = "The ID of the private security group." # Description of the private security group ID output
}

# Output Network ACL IDs
output "public_nacl_id" {
  value       = aws_network_acl.public_nacl.id # Output the ID of the public NACL
  description = "The ID of the public NACL." # Description of the public NACL ID output
}

output "private_nacl_id" {
  value       = aws_network_acl.private_nacl.id # Output the ID of the private NACL
  description = "The ID of the private NACL." # Description of the private NACL ID output
}

--------------------------------------------
2. NAT Configuration
   - NAT Gateway setup
   - NAT Instance alternatives
   - High availability considerations
   - Cost optimization strategies
----------------------------
# Define input variables for NAT configuration
variable "environment" {
  description = "Environment name (e.g., prod, dev, staging)"
  type        = string
  default     = "dev"
}

variable "vpc_id" {
  description = "ID of the VPC where NAT resources will be created"
  type        = string
}

variable "public_subnet_ids" {
  description = "List of public subnet IDs for NAT Gateways"
  type        = list(string)
}

variable "private_subnet_ids" {
  description = "List of private subnet IDs that will use NAT"
  type        = list(string)
}

variable "nat_type" {
  description = "Type of NAT to deploy (gateway or instance)"
  type        = string
  default     = "gateway"
  validation {
    condition     = contains(["gateway", "instance"], var.nat_type)
    error_message = "NAT type must be either 'gateway' or 'instance'."
  }
}

variable "high_availability" {
  description = "Whether to deploy NAT in high availability mode"
  type        = bool
  default     = true
}

# Create Elastic IPs for NAT Gateways
resource "aws_eip" "nat_eip" {
  # Create EIPs based on HA setting - one per AZ if HA, else just one
  count  = var.high_availability ? length(var.public_subnet_ids) : 1
  domain = "vpc"

  tags = {
    Name        = "${var.environment}-nat-eip-${count.index + 1}"
    Environment = var.environment
  }

  lifecycle {
    prevent_destroy = true # Prevent accidental deletion of EIPs
  }
}

# NAT Gateway Configuration
resource "aws_nat_gateway" "nat_gateway" {
  # Only create if nat_type is "gateway"
  count = var.nat_type == "gateway" ? (var.high_availability ? length(var.public_subnet_ids) : 1) : 0

  allocation_id = aws_eip.nat_eip[count.index].id
  subnet_id     = var.public_subnet_ids[count.index]

  tags = {
    Name        = "${var.environment}-nat-gateway-${count.index + 1}"
    Environment = var.environment
  }

  depends_on = [aws_eip.nat_eip]
}

# NAT Instance Configuration
data "aws_ami" "nat_instance" {
  # Only lookup AMI if using NAT instance
  count = var.nat_type == "instance" ? 1 : 0

  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn-ami-vpc-nat-*"]
  }
}

# Security group for NAT instances
resource "aws_security_group" "nat_instance" {
  # Only create if nat_type is "instance"
  count  = var.nat_type == "instance" ? 1 : 0
  vpc_id = var.vpc_id
  name   = "${var.environment}-nat-instance-sg"

  ingress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["10.0.0.0/8"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name        = "${var.environment}-nat-instance-sg"
    Environment = var.environment
  }
}

# Launch Template for NAT instances
resource "aws_launch_template" "nat_instance" {
  # Only create if nat_type is "instance"
  count = var.nat_type == "instance" ? 1 : 0

  name_prefix   = "${var.environment}-nat-instance"
  image_id      = data.aws_ami.nat_instance[0].id
  instance_type = "t3.micro" # Cost-optimized instance type

  network_interfaces {
    associate_public_ip_address = true
    security_groups            = [aws_security_group.nat_instance[0].id]
  }

  user_data = base64encode(<<-EOF
              #!/bin/bash
              sysctl -w net.ipv4.ip_forward=1
              /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
              EOF
  )

  tag_specifications {
    resource_type = "instance"
    tags = {
      Name        = "${var.environment}-nat-instance"
      Environment = var.environment
    }
  }
}

# Auto Scaling Group for NAT instances
resource "aws_autoscaling_group" "nat_instance" {
  # Only create if nat_type is "instance"
  count = var.nat_type == "instance" ? (var.high_availability ? length(var.public_subnet_ids) : 1) : 0

  name                = "${var.environment}-nat-instance-asg-${count.index + 1}"
  desired_capacity    = 1
  max_size           = 1
  min_size           = 1
  target_group_arns  = []
  vpc_zone_identifier = [var.public_subnet_ids[count.index]]

  launch_template {
    id      = aws_launch_template.nat_instance[0].id
    version = "$Latest"
  }
}

# Route tables for private subnets
resource "aws_route_table" "private" {
  count  = var.high_availability ? length(var.private_subnet_ids) : 1
  vpc_id = var.vpc_id

  tags = {
    Name        = "${var.environment}-private-rt-${count.index + 1}"
    Environment = var.environment
  }
}

# Routes for NAT Gateway
resource "aws_route" "nat_gateway" {
  count = var.nat_type == "gateway" ? length(aws_route_table.private.*.id) : 0

  route_table_id         = aws_route_table.private[count.index].id
  destination_cidr_block = "0.0.0.0/0"
  nat_gateway_id         = var.high_availability ? aws_nat_gateway.nat_gateway[count.index].id : aws_nat_gateway.nat_gateway[0].id
}

# Route table associations
resource "aws_route_table_association" "private" {
  count = length(var.private_subnet_ids)

  subnet_id      = var.private_subnet_ids[count.index]
  route_table_id = var.high_availability ? aws_route_table.private[count.index].id : aws_route_table.private[0].id
}

# Provisioner for NAT instance monitoring
resource "null_resource" "nat_monitor" {
  count = var.nat_type == "instance" ? 1 : 0

  provisioner "local-exec" {
    command = <<-EOF
      aws cloudwatch put-metric-alarm \
        --alarm-name ${var.environment}-nat-instance-status \
        --alarm-description "Monitor NAT instance status" \
        --metric-name StatusCheckFailed \
        --namespace AWS/EC2 \
        --statistic Maximum \
        --period 60 \
        --threshold 1 \
        --comparison-operator GreaterThanThreshold \
        --evaluation-periods 2 \
        --alarm-actions ${aws_autoscaling_group.nat_instance[0].arn}
    EOF
  }
}

# Output values
output "nat_gateway_ids" {
  description = "IDs of created NAT Gateways"
  value       = var.nat_type == "gateway" ? aws_nat_gateway.nat_gateway[*].id : null
}

output "nat_gateway_public_ips" {
  description = "Public IPs of NAT Gateways"
  value       = aws_eip.nat_eip[*].public_ip
}

output "private_route_table_ids" {
  description = "IDs of private route tables"
  value       = aws_route_table.private[*].id
}

output "nat_instance_sg_id" {
  description = "Security Group ID for NAT instances"
  value       = var.nat_type == "instance" ? aws_security_group.nat_instance[0].id : null
}
--------------------------------------------
## Level 3: Advanced Implementation
### Module 5: VPC Connectivity Options
1. VPC Peering
   - Peering connection setup
   - Cross-region peering
   - Route table configuration
   - Security considerations
--------------------------------------------
# Provider configuration for primary region
provider "aws" {
  region = var.primary_region
  alias  = "primary"
}

# Provider configuration for secondary region (for cross-region peering)
provider "aws" {
  region = var.secondary_region
  alias  = "secondary"
}

# Input Variables
variable "primary_region" {
  description = "Primary AWS region for VPC peering"
  type        = string
  default     = "us-east-1"
}

variable "secondary_region" {
  description = "Secondary AWS region for cross-region VPC peering"
  type        = string
  default     = "us-west-2"
}

variable "primary_vpc_config" {
  description = "Configuration for the primary VPC"
  type = object({
    vpc_id          = string
    cidr_block      = string
    route_table_ids = list(string)
  })
}

variable "secondary_vpc_config" {
  description = "Configuration for the secondary VPC"
  type = object({
    vpc_id          = string
    cidr_block      = string
    route_table_ids = list(string)
  })
}

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default = {
    Environment = "Production"
    Managed_by  = "Terraform"
  }
}

# Create VPC Peering Connection
resource "aws_vpc_peering_connection" "primary_to_secondary" {
  provider = aws.primary

  vpc_id        = var.primary_vpc_config.vpc_id
  peer_vpc_id   = var.secondary_vpc_config.vpc_id
  peer_region   = var.secondary_region
  auto_accept   = false  # Must be false for cross-region peering

  tags = merge(var.tags, {
    Name = "Primary-to-Secondary-Peering"
    Side = "Requester"
  })

  # Add timeouts for peering operations
  timeouts {
    create = "15m"
    delete = "15m"
  }
}

# Accept VPC Peering Connection (Secondary Region)
resource "aws_vpc_peering_connection_accepter" "secondary_accepter" {
  provider = aws.secondary

  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id
  auto_accept              = true

  tags = merge(var.tags, {
    Name = "Secondary-to-Primary-Peering"
    Side = "Accepter"
  })
}

# Create Routes in Primary VPC Route Tables
resource "aws_route" "primary_to_secondary" {
  provider = aws.primary
  count    = length(var.primary_vpc_config.route_table_ids)

  route_table_id            = var.primary_vpc_config.route_table_ids[count.index]
  destination_cidr_block    = var.secondary_vpc_config.cidr_block
  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id

  # Add timeout for route creation
  timeouts {
    create = "5m"
  }
}

# Create Routes in Secondary VPC Route Tables
resource "aws_route" "secondary_to_primary" {
  provider = aws.secondary
  count    = length(var.secondary_vpc_config.route_table_ids)

  route_table_id            = var.secondary_vpc_config.route_table_ids[count.index]
  destination_cidr_block    = var.primary_vpc_config.cidr_block
  vpc_peering_connection_id = aws_vpc_peering_connection.primary_to_secondary.id

  # Add timeout for route creation
  timeouts {
    create = "5m"
  }
}

# Security Group for Primary VPC
resource "aws_security_group" "primary_peering_sg" {
  provider    = aws.primary
  name        = "primary-peering-sg"
  description = "Security group for VPC peering in primary VPC"
  vpc_id      = var.primary_vpc_config.vpc_id

  # Allow all traffic from secondary VPC
  ingress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = [var.secondary_vpc_config.cidr_block]
    description = "Allow all traffic from secondary VPC"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = [var.secondary_vpc_config.cidr_block]
    description = "Allow all outbound traffic to secondary VPC"
  }

  tags = merge(var.tags, {
    Name = "Primary-Peering-SG"
  })
}

# Security Group for Secondary VPC
resource "aws_security_group" "secondary_peering_sg" {
  provider    = aws.secondary
  name        = "secondary-peering-sg"
  description = "Security group for VPC peering in secondary VPC"
  vpc_id      = var.secondary_vpc_config.vpc_id

  # Allow all traffic from primary VPC
  ingress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = [var.primary_vpc_config.cidr_block]
    description = "Allow all traffic from primary VPC"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = [var.primary_vpc_config.cidr_block]
    description = "Allow all outbound traffic to primary VPC"
  }

  tags = merge(var.tags, {
    Name = "Secondary-Peering-SG"
  })
}

# Provisioner to verify peering connection
resource "null_resource" "verify_peering" {
  depends_on = [
    aws_vpc_peering_connection_accepter.secondary_accepter,
    aws_route.primary_to_secondary,
    aws_route.secondary_to_primary
  ]

  provisioner "local-exec" {
    command = <<-EOF
      echo "Verifying VPC Peering Connection..."
      aws ec2 describe-vpc-peering-connections \
        --vpc-peering-connection-ids ${aws_vpc_peering_connection.primary_to_secondary.id} \
        --region ${var.primary_region} \
        --query 'VpcPeeringConnections[0].Status.Code' \
        --output text
    EOF
  }
}

# CloudWatch Monitoring for Peering Connection
resource "aws_cloudwatch_metric_alarm" "peering_status" {
  provider            = aws.primary
  alarm_name          = "vpc-peering-status-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "StatusCheckFailed"
  namespace           = "AWS/VPC"
  period             = "60"
  statistic          = "Average"
  threshold          = "0"
  alarm_description  = "This metric monitors VPC peering connection status"
  alarm_actions      = []  # Add SNS topic ARN for notifications

  dimensions = {
    VpcPeeringConnectionId = aws_vpc_peering_connection.primary_to_secondary.id
  }
}

# Output Values
output "peering_connection_id" {
  description = "ID of the VPC peering connection"
  value       = aws_vpc_peering_connection.primary_to_secondary.id
}

output "primary_security_group_id" {
  description = "ID of the security group in primary VPC"
  value       = aws_security_group.primary_peering_sg.id
}

output "secondary_security_group_id" {
  description = "ID of the security group in secondary VPC"
  value       = aws_security_group.secondary_peering_sg.id
}

output "peering_connection_status" {
  description = "Status of the VPC peering connection"
  value       = aws_vpc_peering_connection_accepter.secondary_accepter.accept_status
}

# Example usage in terraform.tfvars:
/*
primary_vpc_config = {
  vpc_id          = "vpc-12345"
  cidr_block      = "10.0.0.0/16"
  route_table_ids = ["rtb-12345", "rtb-67890"]
}

secondary_vpc_config = {
  vpc_id          = "vpc-67890"
  cidr_block      = "172.16.0.0/16"
  route_table_ids = ["rtb-abcdef", "rtb-ghijkl"]
}

tags = {
  Environment = "Production"
  Project     = "VPC-Peering"
  Owner       = "Infrastructure-Team"
}
*/
Set up required variables in terraform.tfvars:
primary_region = "us-east-1"
secondary_region = "us-west-2"
primary_vpc_config = {
  vpc_id = "vpc-12345"
  cidr_block = "10.0.0.0/16"
  route_table_ids = ["rtb-12345"]
}
secondary_vpc_config = {
  vpc_id = "vpc-67890"
  cidr_block = "172.16.0.0/16"
  route_table_ids = ["rtb-67890"]
}
--------------------------------------------
2. Transit Gateway
   - Transit Gateway configuration
   - Attachment management
   - Route table associations
   - Multi-account setup
--------------------------------------------
# Provider configuration for transit gateway account
provider "aws" {
  region = var.primary_region
  alias  = "transit_gateway"
  # Assume role for transit gateway account
  assume_role {
    role_arn = var.transit_gateway_account_role_arn
  }
}

# Provider configuration for spoke accounts
provider "aws" {
  region = var.primary_region
  alias  = "spoke"
  # Assume role for spoke account
  assume_role {
    role_arn = var.spoke_account_role_arn
  }
}

# Input Variables
variable "primary_region" {
  description = "AWS region for Transit Gateway deployment"
  type        = string
  default     = "us-east-1"
}

variable "transit_gateway_account_role_arn" {
  description = "IAM role ARN for Transit Gateway account"
  type        = string
}

variable "spoke_account_role_arn" {
  description = "IAM role ARN for spoke account"
  type        = string
}

variable "spoke_vpcs" {
  description = "List of spoke VPCs to attach to Transit Gateway"
  type = list(object({
    vpc_id            = string
    account_id        = string
    cidr_block        = string
    subnet_ids        = list(string)
    route_table_ids   = list(string)
    name              = string
  }))
}

variable "tgw_tags" {
  description = "Tags for Transit Gateway resources"
  type        = map(string)
  default = {
    Environment = "Production"
    Managed_by  = "Terraform"
  }
}

# Create Transit Gateway
resource "aws_ec2_transit_gateway" "main" {
  provider = aws.transit_gateway

  description                     = "Main Transit Gateway"
  amazon_side_asn                = 64512
  auto_accept_shared_attachments = "enable"
  default_route_table_association = "disable"
  default_route_table_propagation = "disable"
  dns_support                    = "enable"
  vpn_ecmp_support              = "enable"

  tags = merge(var.tgw_tags, {
    Name = "Main-Transit-Gateway"
  })
}

# Create Transit Gateway Route Table
resource "aws_ec2_transit_gateway_route_table" "main" {
  provider = aws.transit_gateway

  transit_gateway_id = aws_ec2_transit_gateway.main.id

  tags = merge(var.tgw_tags, {
    Name = "Main-TGW-Route-Table"
  })
}

# Resource Access Manager share for Transit Gateway
resource "aws_ram_resource_share" "tgw_share" {
  provider = aws.transit_gateway

  name                      = "transit-gateway-share"
  allow_external_principals = false

  tags = merge(var.tgw_tags, {
    Name = "TGW-Resource-Share"
  })
}

# Share Transit Gateway with spoke accounts
resource "aws_ram_resource_association" "tgw_share" {
  provider = aws.transit_gateway

  resource_arn       = aws_ec2_transit_gateway.main.arn
  resource_share_arn = aws_ram_resource_share.tgw_share.arn
}

resource "aws_ram_principal_association" "spoke_accounts" {
  provider = aws.transit_gateway
  count    = length(var.spoke_vpcs)

  principal          = var.spoke_vpcs[count.index].account_id
  resource_share_arn = aws_ram_resource_share.tgw_share.arn
}

# Create Transit Gateway Attachments for each spoke VPC
resource "aws_ec2_transit_gateway_vpc_attachment" "spoke_attachments" {
  provider = aws.spoke
  count    = length(var.spoke_vpcs)

  subnet_ids         = var.spoke_vpcs[count.index].subnet_ids
  transit_gateway_id = aws_ec2_transit_gateway.main.id
  vpc_id            = var.spoke_vpcs[count.index].vpc_id

  dns_support                                     = "enable"
  ipv6_support                                   = "disable"
  transit_gateway_default_route_table_association = false
  transit_gateway_default_route_table_propagation = false

  tags = merge(var.tgw_tags, {
    Name = "TGW-Attachment-${var.spoke_vpcs[count.index].name}"
  })
}

# Associate attachments with route table
resource "aws_ec2_transit_gateway_route_table_association" "spoke_associations" {
  provider = aws.transit_gateway
  count    = length(var.spoke_vpcs)

  transit_gateway_attachment_id  = aws_ec2_transit_gateway_vpc_attachment.spoke_attachments[count.index].id
  transit_gateway_route_table_id = aws_ec2_transit_gateway_route_table.main.id
}

# Create routes in Transit Gateway route table
resource "aws_ec2_transit_gateway_route" "spoke_routes" {
  provider = aws.transit_gateway
  count    = length(var.spoke_vpcs)

  destination_cidr_block         = var.spoke_vpcs[count.index].cidr_block
  transit_gateway_attachment_id  = aws_ec2_transit_gateway_vpc_attachment.spoke_attachments[count.index].id
  transit_gateway_route_table_id = aws_ec2_transit_gateway_route_table.main.id
}

# Create routes in VPC route tables
resource "aws_route" "vpc_to_tgw" {
  provider = aws.spoke
  count    = length(local.all_route_table_ids)

  route_table_id         = local.all_route_table_ids[count.index]
  destination_cidr_block = "10.0.0.0/8"  # Adjust based on your network design
  transit_gateway_id     = aws_ec2_transit_gateway.main.id
}

# Local variable to flatten route table IDs
locals {
  all_route_table_ids = flatten([
    for vpc in var.spoke_vpcs : vpc.route_table_ids
  ])
}

# CloudWatch Monitoring
resource "aws_cloudwatch_metric_alarm" "tgw_bandwidth" {
  provider = aws.transit_gateway

  alarm_name          = "tgw-bandwidth-alarm"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "BytesProcessed"
  namespace           = "AWS/TransitGateway"
  period             = "300"
  statistic          = "Average"
  threshold          = "1000000000"  # 1 GB
  alarm_description  = "Transit Gateway bandwidth exceeded threshold"

  dimensions = {
    TransitGateway = aws_ec2_transit_gateway.main.id
  }
}

# Provisioner for monitoring setup
resource "null_resource" "monitoring_setup" {
  depends_on = [aws_ec2_transit_gateway.main]

  provisioner "local-exec" {
    command = <<-EOF
      aws cloudwatch put-dashboard \
        --dashboard-name TGWMonitoring \
        --dashboard-body "{
          \"widgets\": [
            {
              \"type\": \"metric\",
              \"properties\": {
                \"metrics\": [[\"AWS/TransitGateway\", \"BytesIn\", \"TransitGateway\", \"${aws_ec2_transit_gateway.main.id}\"]],
                \"period\": 300,
                \"stat\": \"Average\",
                \"region\": \"${var.primary_region}\",
                \"title\": \"Transit Gateway Bytes In\"
              }
            }
          ]
        }"
    EOF
  }
}

# Outputs
output "transit_gateway_id" {
  description = "ID of the created Transit Gateway"
  value       = aws_ec2_transit_gateway.main.id
}

output "transit_gateway_route_table_id" {
  description = "ID of the main Transit Gateway route table"
  value       = aws_ec2_transit_gateway_route_table.main.id
}

output "attachment_ids" {
  description = "IDs of the Transit Gateway VPC attachments"
  value       = aws_ec2_transit_gateway_vpc_attachment.spoke_attachments[*].id
}

output "resource_share_arn" {
  description = "ARN of the Resource Access Manager share"
  value       = aws_ram_resource_share.tgw_share.arn
}

# Example usage in terraform.tfvars:
/*
primary_region = "us-east-1"
transit_gateway_account_role_arn = "arn:aws:iam::111111111111:role/tgw-admin"
spoke_account_role_arn = "arn:aws:iam::222222222222:role/spoke-admin"

spoke_vpcs = [
  {
    vpc_id = "vpc-11111111"
    account_id = "222222222222"
    cidr_block = "10.1.0.0/16"
    subnet_ids = ["subnet-11111111", "subnet-22222222"]
    route_table_ids = ["rtb-11111111"]
    name = "prod-vpc"
  },
  {
    vpc_id = "vpc-22222222"
    account_id = "333333333333"
    cidr_block = "10.2.0.0/16"
    subnet_ids = ["subnet-33333333", "subnet-44444444"]
    route_table_ids = ["rtb-22222222"]
    name = "dev-vpc"
  }
]

tgw_tags = {
  Environment = "Production"
  Project     = "Network-Hub"
  Owner       = "Network-Team"
}
*/
--------------------------------------------
### Module 6: Advanced Networking Features
1. VPC Endpoints
   - Interface endpoints
   - Gateway endpoints
   - Endpoint policies
   - Private connectivity to AWS services
--------------------------------------------
# Provider configuration
provider "aws" {
  region = var.region
}

# Input Variables
variable "region" {
  description = "AWS region for VPC endpoint deployment"
  type        = string
  default     = "us-east-1"
}

variable "vpc_id" {
  description = "ID of the VPC where endpoints will be created"
  type        = string
}

variable "subnet_ids" {
  description = "List of subnet IDs for interface endpoints"
  type        = list(string)
}

variable "private_route_table_ids" {
  description = "List of private route table IDs for gateway endpoints"
  type        = list(string)
}

variable "tags" {
  description = "Common tags for all resources"
  type        = map(string)
  default = {
    Environment = "Production"
    Managed_by  = "Terraform"
  }
}

# Security Group for Interface Endpoints
resource "aws_security_group" "vpc_endpoints" {
  name        = "vpc-endpoints-sg"
  description = "Security group for VPC Interface Endpoints"
  vpc_id      = var.vpc_id

  ingress {
    description = "HTTPS from VPC"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = [data.aws_vpc.selected.cidr_block]
  }

  tags = merge(var.tags, {
    Name = "vpc-endpoints-sg"
  })
}

# Data source for VPC information
data "aws_vpc" "selected" {
  id = var.vpc_id
}

# S3 Gateway Endpoint
resource "aws_vpc_endpoint" "s3" {
  vpc_id            = var.vpc_id
  service_name      = "com.amazonaws.${var.region}.s3"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = var.private_route_table_ids

  tags = merge(var.tags, {
    Name = "s3-gateway-endpoint"
  })

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid       = "AllowS3Access"
        Effect    = "Allow"
        Principal = "*"
        Action = [
          "s3:GetObject",
          "s3:PutObject",
          "s3:ListBucket"
        ]
        Resource = [
          "arn:aws:s3:::*"
        ]
      }
    ]
  })
}

# DynamoDB Gateway Endpoint
resource "aws_vpc_endpoint" "dynamodb" {
  vpc_id            = var.vpc_id
  service_name      = "com.amazonaws.${var.region}.dynamodb"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = var.private_route_table_ids

  tags = merge(var.tags, {
    Name = "dynamodb-gateway-endpoint"
  })

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid       = "AllowDynamoDBAccess"
        Effect    = "Allow"
        Principal = "*"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:Query",
          "dynamodb:Scan"
        ]
        Resource = [
          "arn:aws:dynamodb:${var.region}:*:table/*"
        ]
      }
    ]
  })
}

# List of interface endpoint services
locals {
  interface_endpoints = {
    ssm = {
      service             = "ssm"
      private_dns_enabled = true
      policy = jsonencode({
        Version = "2012-10-17"
        Statement = [
          {
            Sid       = "AllowSSMAccess"
            Effect    = "Allow"
            Principal = "*"
            Action    = ["ssm:*"]
            Resource  = "*"
          }
        ]
      })
    }
    ssmmessages = {
      service             = "ssmmessages"
      private_dns_enabled = true
      policy = jsonencode({
        Version = "2012-10-17"
        Statement = [
          {
            Effect    = "Allow"
            Principal = "*"
            Action    = ["ssmmessages:*"]
            Resource  = "*"
          }
        ]
      })
    }
    ec2messages = {
      service             = "ec2messages"
      private_dns_enabled = true
      policy = jsonencode({
        Version = "2012-10-17"
        Statement = [
          {
            Effect    = "Allow"
            Principal = "*"
            Action    = ["ec2messages:*"]
            Resource  = "*"
          }
        ]
      })
    }
    ecr_api = {
      service             = "ecr.api"
      private_dns_enabled = true
      policy = jsonencode({
        Version = "2012-10-17"
        Statement = [
          {
            Effect    = "Allow"
            Principal = "*"
            Action    = ["ecr:*"]
            Resource  = "*"
          }
        ]
      })
    }
    ecr_dkr = {
      service             = "ecr.dkr"
      private_dns_enabled = true
      policy = jsonencode({
        Version = "2012-10-17"
        Statement = [
          {
            Effect    = "Allow"
            Principal = "*"
            Action    = ["ecr:*"]
            Resource  = "*"
          }
        ]
      })
    }
  }
}

# Create Interface Endpoints
resource "aws_vpc_endpoint" "interface_endpoints" {
  for_each = local.interface_endpoints

  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.${each.value.service}"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [aws_security_group.vpc_endpoints.id]
  private_dns_enabled = each.value.private_dns_enabled

  tags = merge(var.tags, {
    Name = "${each.key}-interface-endpoint"
  })

  policy = each.value.policy
}

# CloudWatch Monitoring for Endpoints
resource "aws_cloudwatch_metric_alarm" "endpoint_connectivity" {
  for_each = merge(
    { "s3" = aws_vpc_endpoint.s3.id, "dynamodb" = aws_vpc_endpoint.dynamodb.id },
    { for k, v in aws_vpc_endpoint.interface_endpoints : k => v.id }
  )

  alarm_name          = "vpc-endpoint-${each.key}-connectivity"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "ConnectionAttemptCount"
  namespace           = "AWS/VpcEndpoints"
  period             = "300"
  statistic          = "Sum"
  threshold          = "100"
  alarm_description  = "Monitor VPC endpoint connectivity issues"

  dimensions = {
    VpcEndpointId = each.value
  }

  tags = merge(var.tags, {
    Name = "endpoint-connectivity-${each.key}"
  })
}

# Provisioner for endpoint monitoring setup
resource "null_resource" "endpoint_monitoring" {
  for_each = aws_vpc_endpoint.interface_endpoints

  provisioner "local-exec" {
    command = <<-EOF
      aws cloudwatch put-metric-alarm \
        --alarm-name ${each.key}-endpoint-health \
        --alarm-description "Monitor endpoint health for ${each.key}" \
        --metric-name HealthCheckStatus \
        --namespace AWS/VpcEndpoints \
        --statistic Minimum \
        --period 60 \
        --threshold 1 \
        --comparison-operator LessThanThreshold \
        --dimensions Name=VpcEndpointId,Value=${each.value.id} \
        --evaluation-periods 2 \
        --alarm-actions ${var.sns_topic_arn} \
        --region ${var.region}
    EOF
  }
}

# Outputs
output "s3_endpoint_id" {
  description = "ID of the S3 Gateway endpoint"
  value       = aws_vpc_endpoint.s3.id
}

output "dynamodb_endpoint_id" {
  description = "ID of the DynamoDB Gateway endpoint"
  value       = aws_vpc_endpoint.dynamodb.id
}

output "interface_endpoint_ids" {
  description = "Map of interface endpoint names to their IDs"
  value       = { for k, v in aws_vpc_endpoint.interface_endpoints : k => v.id }
}

output "endpoint_security_group_id" {
  description = "ID of the security group created for interface endpoints"
  value       = aws_security_group.vpc_endpoints.id
}

# Example usage in terraform.tfvars:
/*
region = "us-east-1"
vpc_id = "vpc-12345678"
subnet_ids = ["subnet-12345678", "subnet-87654321"]
private_route_table_ids = ["rtb-12345678"]
tags = {
  Environment = "Production"
  Project     = "VPC-Endpoints"
  Owner       = "Infrastructure-Team"
}
*/
--------------------------------------------
2. Flow Logs
   - VPC flow log configuration
   - Log analysis and monitoring
   - CloudWatch integration
   - S3 and CloudWatch Logs as destinations
--------------------------------------------

--------------------------------------------
## Level 4: Enterprise Implementation
### Module 7: Multi-Account Network Architecture
1. Landing Zone Setup
   - Account structure
   - Network segmentation
   - Shared services VPC
   - Cross-account access

2. Hybrid Connectivity
   - Site-to-Site VPN
   - Direct Connect setup
   - BGP routing
   - High availability design

### Module 8: Security and Compliance
1. Network Security Controls
   - AWS Network Firewall
   - GuardDuty integration
   - Security Hub implementation
   - WAF integration

2. Compliance and Governance
   - Network isolation patterns
   - Compliance requirements
   - Policy as code
   - Automated compliance checks

## Level 5: Infrastructure as Code Best Practices
### Module 9: Terraform Advanced Concepts
1. Module Development
   - Custom module creation
   - Module versioning
   - Module composition
   - Remote module usage

2. State Management
   - Remote state configuration
   - State locking
   - Workspace management
   - State file backup strategies

### Module 10: CI/CD Integration
1. Pipeline Setup
   - GitHub Actions integration
   - AWS CodePipeline setup
   - Automated testing
   - Infrastructure deployment strategies

2. Monitoring and Maintenance
   - Infrastructure monitoring
   - Cost optimization
   - Performance metrics
   - Automated remediation

## Practical Assignments
1. Basic VPC Setup
   - Create a VPC with public and private subnets
   - Implement basic routing
   - Configure security groups

2. Intermediate Implementation
   - Set up VPC peering
   - Implement NAT Gateway
   - Configure VPC endpoints

3. Advanced Architecture
   - Build a multi-account network
   - Implement Transit Gateway
   - Set up hybrid connectivity

4. Enterprise Project
   - Design and implement a complete enterprise network
   - Include security controls
   - Implement monitoring and logging
   - Deploy using CI/CD pipeline